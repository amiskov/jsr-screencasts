# Таймеры, process.nextTick, ref/unref
В Ноде тоже есть `setTimeout/Interval` и работают они практически так же, как в браузере. Только возвращают объет в качестве идентификатора для `clearTimeout/Interval`.

В идентификаторе `setInterval` есть метод `unref`, который указывает libUV, что это второстепенный таймер и его не нужно учитывать при обработке внутренних вотчеров на завершение процесса. Завешилось остальное — завершаем и таймер:

```js
const interval = setInterval(() => {
    console.log(process.memoryUsage());
}, 1000);

interval.unref();
```

Есть еще метод `ref`, противоположный `unref` если мы передумали. Практически не используется.

`unref` есть и у серверов, и у сетевых сокетов.

`process.memoryUsage()` — получить информацию об использованной памяти.

## `setImmediate`
Иногда нужно отложить выполнение события на следующую итерацию (тик) событийного цикла. Дедовский способ — обернуть обработчик в `setTimeout(..., 0)`. Но это задержка в 4—10 мс. Для того, чтобы от задржки уйти, придумали `setImmediate(fx)` — запустить `fx` как только освободится движок, поставит в очередь без задержки.

* `setTimeout(fx, 0)` — откладывает выполнение, но дает задержку
* `setInterval(fx)` — откладывает выполнение без задержки

Пример, когда может понадобиться отложить выполнение кода:

```js
// Будет: ->в onclick  !focus!  из onclick-> 
button.onclick = function() {
    text.value += ' ->в onclick ';

    text.focus(); // вызов инициирует событие onfocus и оно сразу же начнется

    text.value += ' из onclick-> ';
  };

  text.onfocus = function() {
    text.value += ' !focus! ';
  };
```

А так `focus()` не будет прерывать `onclick`:

```js
// Будет: ->в onclick  из onclick-> !focus!
button.onclick = function() {
    text.value += ' ->в onclick ';

    setImmediate(() => {
        text.focus(); // вызовется после того, как дообрабатывается onclick
    });

    text.value += ' из onclick-> ';
  };

  text.onfocus = function() {
    text.value += ' !focus! ';
  };
```

Понять это поможет два параграфа:
* [Порядок обработки событий, Вложенные (синхронные) события](http://learn.javascript.ru/events-and-timing-depth#вложенные-синхронные-события)
* [Асинхронное выполнение: setImmediate](http://learn.javascript.ru/setimmediate)

В Ноде есть `process.nextTick(fx)`, который асинхронно запустит операцию (после текущего JS), но до любых I/O процессов.

`setImmediate(fx)` планирует выполнение операции _после_ IO процессов, на следующую итерацию событийного цикла (после обработки текущих событий).

Чаще всего в Ноде используют `process.nextTick(fx)`. `setImmediate` больше подойдет для отложенных вычислений или когда нам без разницы, когда именно запустится код относительно текущих событий.

* `process.nextTick` — это как `setTimeout(fx, 0)` до I/O операций, после текущего JS, но в текущей итерации событийного цикла.
* `setImmediate` — это как `setTimeout(fx, 0)` после I/O операций, на следующей итерации событийного цикла.
